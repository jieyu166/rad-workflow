<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å­—å¹•å°é½Šå·¥å…·</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
        }

        h1 {
            text-align: center;
            padding: 15px;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            background: rgba(0, 0, 0, 0.3);
        }

        /* Fixed Video Section */
        .video-section {
            position: sticky;
            top: 0;
            z-index: 100;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 15px;
            border-bottom: 2px solid rgba(0, 212, 255, 0.3);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        .video-top-row {
            display: flex;
            gap: 15px;
            align-items: flex-start;
            max-width: 1400px;
            margin: 0 auto;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            flex: 1;
            max-width: 800px;
        }

        #videoPlayer {
            width: 100%;
            display: block;
            max-height: 400px;
        }

        .subtitle-overlay {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 90%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .subtitle-line {
            padding: 6px 14px;
            border-radius: 5px;
            font-size: 1.1em;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
            display: none;
            max-width: 100%;
        }

        .subtitle-line.visible {
            display: inline-block;
        }

        .subtitle-line.sub1 {
            background: rgba(255, 200, 0, 0.9);
            color: #000;
        }

        .subtitle-line.sub2 {
            background: rgba(0, 200, 255, 0.9);
            color: #000;
        }

        /* File inputs on the right */
        .file-inputs-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 280px;
        }

        .file-input-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
        }

        .file-input-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            font-weight: 500;
        }

        input[type="file"] {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 0.85em;
        }

        input[type="file"]:hover {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
        }

        /* Video Controls */
        .video-controls {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .current-time-display {
            font-family: monospace;
            font-size: 1em;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }

        /* Status Bar */
        .status-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            font-size: 0.85em;
            flex-wrap: wrap;
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #888;
        }

        .status-dot.loaded {
            background: #00c853;
        }

        .color-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 3px;
            vertical-align: middle;
        }

        .color-indicator.sub1 {
            background: #ffc800;
        }

        .color-indicator.sub2 {
            background: #00c8ff;
        }

        /* Scrollable Content Area */
        .content-area {
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .panels-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1000px) {
            .panels-grid {
                grid-template-columns: 1fr;
            }
            .video-top-row {
                flex-direction: column;
            }
            .file-inputs-column {
                flex-direction: row;
                flex-wrap: wrap;
            }
            .file-input-group {
                flex: 1;
                min-width: 200px;
            }
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-title {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #00d4ff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-title::before {
            content: '';
            width: 4px;
            height: 20px;
            background: #00d4ff;
            border-radius: 2px;
        }

        /* Time Offset Controls */
        .offset-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .offset-row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .offset-label {
            min-width: 70px;
            font-weight: 500;
            font-size: 0.9em;
        }

        .time-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .time-input {
            width: 65px;
            padding: 6px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: #fff;
            text-align: center;
            font-size: 0.95em;
        }

        .time-input:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .time-unit {
            font-size: 0.85em;
            color: #888;
        }

        .offset-total {
            font-family: monospace;
            font-size: 0.9em;
        }

        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #00d4ff;
            color: #000;
        }

        .btn-primary:hover {
            background: #00b8e6;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .btn-success {
            background: #00c853;
            color: #fff;
        }

        .btn-success:hover {
            background: #00a844;
        }

        /* Slider */
        .slider-container {
            flex: 1;
            min-width: 150px;
        }

        .offset-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }

        .offset-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .offset-slider.sub1::-webkit-slider-thumb {
            background: #ffc800;
        }

        .offset-slider.sub2::-webkit-slider-thumb {
            background: #00c8ff;
        }

        /* Quick Adjust Buttons */
        .quick-adjust {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .quick-adjust .btn {
            padding: 4px 8px;
            font-size: 0.8em;
            min-width: 45px;
        }

        /* Subtitle List */
        .subtitle-list-container {
            max-height: 250px;
            overflow-y: auto;
            margin-top: 12px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .subtitle-list {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }

        .subtitle-list th,
        .subtitle-list td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .subtitle-list th {
            background: rgba(0, 0, 0, 0.5);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .subtitle-list tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .subtitle-list tr.active {
            background: rgba(0, 212, 255, 0.2);
        }

        .subtitle-list tr.active.sub1 {
            background: rgba(255, 200, 0, 0.2);
        }

        .subtitle-list tr.active.sub2 {
            background: rgba(0, 200, 255, 0.2);
        }

        .time-cell {
            font-family: monospace;
            white-space: nowrap;
            font-size: 0.85em;
        }

        .text-cell {
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Save Section */
        .save-section {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .save-btn {
            padding: 10px 20px;
            font-size: 0.95em;
        }

        /* Instructions - moved to bottom */
        .instructions {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .instructions h3 {
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .instructions ul {
            margin-left: 20px;
        }

        .instructions li {
            margin: 5px 0;
            font-size: 0.9em;
        }

        /* Debug info */
        .debug-info {
            font-size: 0.8em;
            color: #888;
            margin-top: 5px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <h1>ğŸ¬ å­—å¹•å°é½Šå·¥å…·</h1>

    <!-- Fixed Video Section -->
    <div class="video-section">
        <div class="video-top-row">
            <div class="video-container">
                <video id="videoPlayer" controls>
                    <source src="" type="video/mp4">
                    æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´å½±ç‰‡æ’­æ”¾
                </video>
                <div class="subtitle-overlay">
                    <div id="subtitleDisplay1" class="subtitle-line sub1"></div>
                    <div id="subtitleDisplay2" class="subtitle-line sub2"></div>
                </div>
            </div>

            <div class="file-inputs-column">
                <div class="file-input-group">
                    <label>ğŸ“ å½±ç‰‡æª”æ¡ˆï¼š</label>
                    <input type="file" id="videoInput" accept="video/*">
                </div>
                <div class="file-input-group">
                    <label><span class="color-indicator sub1"></span> å­—å¹• 1 (.srt/.vtt)ï¼š</label>
                    <input type="file" id="subtitle1Input" accept=".srt,.vtt,.txt">
                </div>
                <div class="file-input-group">
                    <label><span class="color-indicator sub2"></span> å­—å¹• 2 (.srt/.vtt)ï¼š</label>
                    <input type="file" id="subtitle2Input" accept=".srt,.vtt,.txt">
                </div>
            </div>
        </div>

        <div class="video-controls">
            <span class="current-time-display">ç•¶å‰æ™‚é–“ï¼š<span id="currentTime">00:00:00.000</span></span>
            <button class="btn btn-secondary" onclick="skipTime(-5)">âª -5ç§’</button>
            <button class="btn btn-secondary" onclick="skipTime(-1)">â—€ -1ç§’</button>
            <button class="btn btn-primary" onclick="togglePlay()">â¯ æ’­æ”¾/æš«åœ</button>
            <button class="btn btn-secondary" onclick="skipTime(1)">â–¶ +1ç§’</button>
            <button class="btn btn-secondary" onclick="skipTime(5)">â© +5ç§’</button>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <span class="status-dot" id="videoStatus"></span>
                <span>å½±ç‰‡ï¼š<span id="videoName">æœªè¼‰å…¥</span></span>
            </div>
            <div class="status-item">
                <span class="color-indicator sub1"></span>
                <span class="status-dot" id="sub1Status"></span>
                <span>å­—å¹•1ï¼š<span id="sub1Name">æœªè¼‰å…¥</span> <span id="sub1Count" class="debug-info"></span></span>
            </div>
            <div class="status-item">
                <span class="color-indicator sub2"></span>
                <span class="status-dot" id="sub2Status"></span>
                <span>å­—å¹•2ï¼š<span id="sub2Name">æœªè¼‰å…¥</span> <span id="sub2Count" class="debug-info"></span></span>
            </div>
        </div>
    </div>

    <!-- Scrollable Content Area -->
    <div class="content-area">
        <div class="panels-grid">
            <!-- Subtitle 1 Panel -->
            <div class="panel">
                <div class="panel-title"><span class="color-indicator sub1"></span>å­—å¹• 1 èª¿æ•´</div>
                
                <div class="offset-controls">
                    <div class="offset-row">
                        <span class="offset-label">æ™‚é–“åç§»ï¼š</span>
                        <div class="time-input-group">
                            <input type="number" id="offset1Min" class="time-input" value="0" min="-60" max="60">
                            <span class="time-unit">åˆ†</span>
                            <input type="number" id="offset1Sec" class="time-input" value="0" step="0.1" min="-59.9" max="59.9">
                            <span class="time-unit">ç§’</span>
                        </div>
                        <span id="offset1Total" class="offset-total" style="color: #ffc800;">= 0.000 ç§’</span>
                    </div>
                    
                    <div class="offset-row">
                        <div class="slider-container">
                            <input type="range" id="offset1Slider" class="offset-slider sub1" 
                                   min="-60" max="60" value="0" step="0.1">
                        </div>
                    </div>

                    <div class="offset-row">
                        <span class="offset-label">å¿«é€Ÿèª¿æ•´ï¼š</span>
                        <div class="quick-adjust">
                            <button class="btn btn-secondary" onclick="adjustOffset(1, -5)">-5s</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(1, -1)">-1s</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(1, -0.5)">-0.5s</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(1, -0.1)">-0.1s</button>
                            <button class="btn btn-primary" onclick="resetOffset(1)">æ­¸é›¶</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(1, 0.1)">+0.1s</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(1, 0.5)">+0.5s</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(1, 1)">+1s</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(1, 5)">+5s</button>
                        </div>
                    </div>
                </div>

                <div class="subtitle-list-container">
                    <table class="subtitle-list">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>åŸå§‹æ™‚é–“</th>
                                <th>èª¿æ•´å¾Œ</th>
                                <th>å…§å®¹</th>
                            </tr>
                        </thead>
                        <tbody id="subtitleList1"></tbody>
                    </table>
                </div>

                <div class="save-section">
                    <button class="btn btn-success save-btn" onclick="saveSubtitle(1, 'srt')">ğŸ’¾ å„²å­˜ SRT</button>
                    <button class="btn btn-success save-btn" onclick="saveSubtitle(1, 'vtt')">ğŸ’¾ å„²å­˜ VTT</button>
                </div>
            </div>

            <!-- Subtitle 2 Panel -->
            <div class="panel">
                <div class="panel-title"><span class="color-indicator sub2"></span>å­—å¹• 2 èª¿æ•´</div>
                
                <div class="offset-controls">
                    <div class="offset-row">
                        <span class="offset-label">æ™‚é–“åç§»ï¼š</span>
                        <div class="time-input-group">
                            <input type="number" id="offset2Min" class="time-input" value="0" min="-60" max="60">
                            <span class="time-unit">åˆ†</span>
                            <input type="number" id="offset2Sec" class="time-input" value="0" step="0.1" min="-59.9" max="59.9">
                            <span class="time-unit">ç§’</span>
                        </div>
                        <span id="offset2Total" class="offset-total" style="color: #00c8ff;">= 0.000 ç§’</span>
                    </div>
                    
                    <div class="offset-row">
                        <div class="slider-container">
                            <input type="range" id="offset2Slider" class="offset-slider sub2" 
                                   min="-60" max="60" value="0" step="0.1">
                        </div>
                    </div>

                    <div class="offset-row">
                        <span class="offset-label">å¿«é€Ÿèª¿æ•´ï¼š</span>
                        <div class="quick-adjust">
                            <button class="btn btn-secondary" onclick="adjustOffset(2, -5)">-5s</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(2, -1)">-1s</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(2, -0.5)">-0.5s</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(2, -0.1)">-0.1s</button>
                            <button class="btn btn-primary" onclick="resetOffset(2)">æ­¸é›¶</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(2, 0.1)">+0.1s</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(2, 0.5)">+0.5s</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(2, 1)">+1s</button>
                            <button class="btn btn-secondary" onclick="adjustOffset(2, 5)">+5s</button>
                        </div>
                    </div>
                </div>

                <div class="subtitle-list-container">
                    <table class="subtitle-list">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>åŸå§‹æ™‚é–“</th>
                                <th>èª¿æ•´å¾Œ</th>
                                <th>å…§å®¹</th>
                            </tr>
                        </thead>
                        <tbody id="subtitleList2"></tbody>
                    </table>
                </div>

                <div class="save-section">
                    <button class="btn btn-success save-btn" onclick="saveSubtitle(2, 'srt')">ğŸ’¾ å„²å­˜ SRT</button>
                    <button class="btn btn-success save-btn" onclick="saveSubtitle(2, 'vtt')">ğŸ’¾ å„²å­˜ VTT</button>
                </div>
            </div>
        </div>

        <!-- Instructions at bottom -->
        <div class="instructions">
            <h3>ğŸ“– ä½¿ç”¨èªªæ˜</h3>
            <ul>
                <li>æ”¯æ´ <strong>.srt</strong> å’Œ <strong>.vtt</strong> å­—å¹•æ ¼å¼</li>
                <li>è¼‰å…¥å½±ç‰‡å’Œå­—å¹•å¾Œï¼Œå¯é€éæ»‘æ¡¿æˆ–è¼¸å…¥æ¡†èª¿æ•´æ™‚é–“åç§»</li>
                <li>ä½¿ç”¨å¿«é€Ÿèª¿æ•´æŒ‰éˆ•å¯å¾®èª¿æ™‚é–“ï¼ˆÂ±0.1ç§’ã€Â±0.5ç§’ã€Â±1ç§’ã€Â±5ç§’ï¼‰</li>
                <li>å­—å¹•æœƒå³æ™‚é¡¯ç¤ºåœ¨å½±ç‰‡ä¸Šæ–¹ï¼Œæ–¹ä¾¿ç¢ºèªå°é½Šæ•ˆæœ</li>
                <li>èª¿æ•´å®Œæˆå¾Œå¯å„²å­˜ç‚º SRT æˆ– VTT æ ¼å¼</li>
                <li>å¿«æ·éµï¼šç©ºç™½éµ = æ’­æ”¾/æš«åœï¼Œæ–¹å‘éµå·¦å³ = Â±5ç§’</li>
            </ul>
        </div>
    </div>

    <script>
        // Global state
        const state = {
            subtitles1: [],
            subtitles2: [],
            offset1: 0,
            offset2: 0,
            videoLoaded: false,
            originalFilename1: 'subtitle1',
            originalFilename2: 'subtitle2'
        };

        // DOM elements
        const videoPlayer = document.getElementById('videoPlayer');
        const videoInput = document.getElementById('videoInput');
        const subtitle1Input = document.getElementById('subtitle1Input');
        const subtitle2Input = document.getElementById('subtitle2Input');

        // Normalize line endings and remove BOM
        function normalizeText(content) {
            // Remove BOM if present
            if (content.charCodeAt(0) === 0xFEFF) {
                content = content.slice(1);
            }
            // Normalize all line endings to \n
            return content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        }

        // Parse time string to seconds
        function parseTime(timeStr) {
            if (!timeStr) return 0;
            
            // Clean the time string
            timeStr = timeStr.trim();
            
            // Handle both SRT (00:00:00,000) and VTT (00:00:00.000) formats
            const normalized = timeStr.replace(',', '.');
            const parts = normalized.split(':');
            
            if (parts.length === 3) {
                const hours = parseFloat(parts[0]) || 0;
                const minutes = parseFloat(parts[1]) || 0;
                const seconds = parseFloat(parts[2]) || 0;
                return hours * 3600 + minutes * 60 + seconds;
            } else if (parts.length === 2) {
                const minutes = parseFloat(parts[0]) || 0;
                const seconds = parseFloat(parts[1]) || 0;
                return minutes * 60 + seconds;
            }
            return parseFloat(normalized) || 0;
        }

        // Format seconds to time string
        function formatTime(seconds, format = 'srt') {
            const negative = seconds < 0;
            seconds = Math.abs(seconds);
            
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            const separator = format === 'vtt' ? '.' : ',';
            const secsStr = secs.toFixed(3).padStart(6, '0').replace('.', separator);
            const result = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${secsStr}`;
            
            return negative ? `-${result}` : result;
        }

        // Format for display
        function formatTimeDisplay(seconds) {
            if (seconds < 0) {
                return '-' + formatTimeDisplay(-seconds);
            }
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = (seconds % 60).toFixed(3);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${secs.padStart(6, '0')}`;
        }

        // Short time format for table
        function formatTimeShort(seconds) {
            if (seconds < 0) return '-' + formatTimeShort(-seconds);
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = (seconds % 60).toFixed(1);
            if (hours > 0) {
                return `${hours}:${String(minutes).padStart(2, '0')}:${secs.padStart(4, '0')}`;
            }
            return `${minutes}:${secs.padStart(4, '0')}`;
        }

        // Parse SRT format - robust version
        function parseSRT(content) {
            const subtitles = [];
            content = normalizeText(content);
            
            // Split by double newlines (or more)
            const blocks = content.split(/\n\s*\n/);
            
            console.log(`SRT: Found ${blocks.length} blocks`);
            
            for (const block of blocks) {
                const lines = block.trim().split('\n').map(l => l.trim()).filter(l => l.length > 0);
                if (lines.length < 2) continue;
                
                // Find the timing line (contains -->)
                let timingIndex = -1;
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].includes('-->')) {
                        timingIndex = i;
                        break;
                    }
                }
                
                if (timingIndex === -1) continue;
                
                // Parse timing line
                const timingLine = lines[timingIndex];
                const arrowIndex = timingLine.indexOf('-->');
                if (arrowIndex === -1) continue;
                
                const startTimeStr = timingLine.substring(0, arrowIndex).trim();
                let endTimeStr = timingLine.substring(arrowIndex + 3).trim();
                
                // Remove any positioning info after end time
                const spaceIndex = endTimeStr.indexOf(' ');
                if (spaceIndex !== -1) {
                    endTimeStr = endTimeStr.substring(0, spaceIndex);
                }
                
                const startTime = parseTime(startTimeStr);
                const endTime = parseTime(endTimeStr);
                
                // Get text (all lines after timing)
                const text = lines.slice(timingIndex + 1).join('\n');
                
                if (text.trim() && !isNaN(startTime) && !isNaN(endTime)) {
                    subtitles.push({
                        index: subtitles.length + 1,
                        startTime,
                        endTime,
                        text: text.trim()
                    });
                }
            }
            
            console.log(`SRT: Parsed ${subtitles.length} subtitles`);
            return subtitles;
        }

        // Parse VTT format - robust version
        function parseVTT(content) {
            const subtitles = [];
            content = normalizeText(content);
            
            // Remove WEBVTT header and metadata
            const lines = content.split('\n');
            let startLine = 0;
            
            // Skip header lines until we find a timing line
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes('-->')) {
                    // Go back to find the start of this block
                    startLine = i;
                    // Check if previous line is a cue identifier
                    if (i > 0 && lines[i-1].trim() && !lines[i-1].includes('-->') && !lines[i-1].startsWith('NOTE')) {
                        startLine = i - 1;
                    }
                    break;
                }
            }
            
            const relevantContent = lines.slice(startLine).join('\n');
            const blocks = relevantContent.split(/\n\s*\n/);
            
            console.log(`VTT: Found ${blocks.length} blocks`);
            
            for (const block of blocks) {
                const blockLines = block.trim().split('\n').map(l => l.trim()).filter(l => l.length > 0);
                if (blockLines.length < 1) continue;
                
                // Find the timing line
                let timingIndex = -1;
                for (let i = 0; i < blockLines.length; i++) {
                    if (blockLines[i].includes('-->')) {
                        timingIndex = i;
                        break;
                    }
                }
                
                if (timingIndex === -1) continue;
                
                // Parse timing line
                const timingLine = blockLines[timingIndex];
                const arrowIndex = timingLine.indexOf('-->');
                if (arrowIndex === -1) continue;
                
                const startTimeStr = timingLine.substring(0, arrowIndex).trim();
                let endTimeStr = timingLine.substring(arrowIndex + 3).trim();
                
                // Remove any positioning info
                const spaceIndex = endTimeStr.indexOf(' ');
                if (spaceIndex !== -1) {
                    endTimeStr = endTimeStr.substring(0, spaceIndex);
                }
                
                const startTime = parseTime(startTimeStr);
                const endTime = parseTime(endTimeStr);
                
                // Get text (all lines after timing)
                const text = blockLines.slice(timingIndex + 1).join('\n');
                
                if (text.trim() && !isNaN(startTime) && !isNaN(endTime)) {
                    subtitles.push({
                        index: subtitles.length + 1,
                        startTime,
                        endTime,
                        text: text.trim()
                    });
                }
            }
            
            console.log(`VTT: Parsed ${subtitles.length} subtitles`);
            return subtitles;
        }

        // Detect format and parse
        function parseSubtitle(content, filename) {
            content = normalizeText(content);
            const isVTT = filename.toLowerCase().endsWith('.vtt') || content.trim().startsWith('WEBVTT');
            const subtitles = isVTT ? parseVTT(content) : parseSRT(content);
            
            // Sort by start time just in case
            subtitles.sort((a, b) => a.startTime - b.startTime);
            
            // Re-index
            subtitles.forEach((sub, i) => sub.index = i + 1);
            
            return subtitles;
        }

        // Generate SRT content
        function generateSRT(subtitles, offset) {
            return subtitles.map((sub, index) => {
                const newStart = Math.max(0, sub.startTime + offset);
                const newEnd = Math.max(0, sub.endTime + offset);
                return `${index + 1}\n${formatTime(newStart, 'srt')} --> ${formatTime(newEnd, 'srt')}\n${sub.text}`;
            }).join('\n\n');
        }

        // Generate VTT content
        function generateVTT(subtitles, offset) {
            const content = subtitles.map((sub, index) => {
                const newStart = Math.max(0, sub.startTime + offset);
                const newEnd = Math.max(0, sub.endTime + offset);
                return `${index + 1}\n${formatTime(newStart, 'vtt')} --> ${formatTime(newEnd, 'vtt')}\n${sub.text}`;
            }).join('\n\n');
            return `WEBVTT\n\n${content}`;
        }

        // Update subtitle list display
        function updateSubtitleList(subNum) {
            const subtitles = subNum === 1 ? state.subtitles1 : state.subtitles2;
            const offset = subNum === 1 ? state.offset1 : state.offset2;
            const listElement = document.getElementById(`subtitleList${subNum}`);
            
            listElement.innerHTML = subtitles.map(sub => {
                const adjustedStart = sub.startTime + offset;
                const adjustedEnd = sub.endTime + offset;
                // Get first line only for display
                const firstLine = sub.text.split('\n')[0];
                return `
                    <tr data-start="${adjustedStart}" data-end="${adjustedEnd}" class="sub${subNum}">
                        <td>${sub.index}</td>
                        <td class="time-cell">${formatTimeShort(sub.startTime)}</td>
                        <td class="time-cell">${formatTimeShort(adjustedStart)}</td>
                        <td class="text-cell" title="${sub.text.replace(/"/g, '&quot;')}">${firstLine}</td>
                    </tr>
                `;
            }).join('');
        }

        // Update offset display
        function updateOffsetDisplay(subNum) {
            const offset = subNum === 1 ? state.offset1 : state.offset2;
            
            document.getElementById(`offset${subNum}Min`).value = Math.floor(offset / 60);
            document.getElementById(`offset${subNum}Sec`).value = (offset % 60).toFixed(1);
            document.getElementById(`offset${subNum}Slider`).value = Math.max(-60, Math.min(60, offset));
            document.getElementById(`offset${subNum}Total`).textContent = `= ${offset.toFixed(3)} ç§’`;
        }

        // Set offset from inputs
        function setOffsetFromInputs(subNum) {
            const minutes = parseFloat(document.getElementById(`offset${subNum}Min`).value) || 0;
            const seconds = parseFloat(document.getElementById(`offset${subNum}Sec`).value) || 0;
            const totalOffset = minutes * 60 + seconds;
            
            if (subNum === 1) {
                state.offset1 = totalOffset;
            } else {
                state.offset2 = totalOffset;
            }
            
            updateOffsetDisplay(subNum);
            updateSubtitleList(subNum);
        }

        // Adjust offset by delta
        function adjustOffset(subNum, delta) {
            if (subNum === 1) {
                state.offset1 += delta;
            } else {
                state.offset2 += delta;
            }
            updateOffsetDisplay(subNum);
            updateSubtitleList(subNum);
        }

        // Reset offset to zero
        function resetOffset(subNum) {
            if (subNum === 1) {
                state.offset1 = 0;
            } else {
                state.offset2 = 0;
            }
            updateOffsetDisplay(subNum);
            updateSubtitleList(subNum);
        }

        // Find current subtitle - returns only ONE matching subtitle
        function findCurrentSubtitle(subtitles, currentTime, offset) {
            for (const sub of subtitles) {
                const adjustedStart = sub.startTime + offset;
                const adjustedEnd = sub.endTime + offset;
                if (currentTime >= adjustedStart && currentTime <= adjustedEnd) {
                    return sub;
                }
            }
            return null;
        }

        // Update subtitle display on video - show only current subtitle
        function updateSubtitleDisplay() {
            const currentTime = videoPlayer.currentTime;
            
            // Update subtitle 1 - show only ONE current subtitle
            const currentSub1 = findCurrentSubtitle(state.subtitles1, currentTime, state.offset1);
            const display1 = document.getElementById('subtitleDisplay1');
            if (currentSub1) {
                display1.innerHTML = currentSub1.text.replace(/\n/g, '<br>');
                display1.classList.add('visible');
            } else {
                display1.classList.remove('visible');
            }
            
            // Update subtitle 2 - show only ONE current subtitle
            const currentSub2 = findCurrentSubtitle(state.subtitles2, currentTime, state.offset2);
            const display2 = document.getElementById('subtitleDisplay2');
            if (currentSub2) {
                display2.innerHTML = currentSub2.text.replace(/\n/g, '<br>');
                display2.classList.add('visible');
            } else {
                display2.classList.remove('visible');
            }
            
            // Update current time display
            document.getElementById('currentTime').textContent = formatTimeDisplay(currentTime);
            
            // Highlight current subtitle in list
            highlightCurrentSubtitle(1, currentTime);
            highlightCurrentSubtitle(2, currentTime);
        }

        // Highlight current subtitle in list
        function highlightCurrentSubtitle(subNum, currentTime) {
            const rows = document.querySelectorAll(`#subtitleList${subNum} tr`);
            rows.forEach(row => {
                const start = parseFloat(row.dataset.start);
                const end = parseFloat(row.dataset.end);
                if (currentTime >= start && currentTime <= end) {
                    row.classList.add('active');
                } else {
                    row.classList.remove('active');
                }
            });
        }

        // Save subtitle file
        function saveSubtitle(subNum, format) {
            const subtitles = subNum === 1 ? state.subtitles1 : state.subtitles2;
            const offset = subNum === 1 ? state.offset1 : state.offset2;
            const originalFilename = subNum === 1 ? state.originalFilename1 : state.originalFilename2;
            
            if (subtitles.length === 0) {
                alert('è«‹å…ˆè¼‰å…¥å­—å¹•æª”æ¡ˆï¼');
                return;
            }
            
            const content = format === 'vtt' ? generateVTT(subtitles, offset) : generateSRT(subtitles, offset);
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${originalFilename}_adjusted.${format}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Video controls
        function togglePlay() {
            if (videoPlayer.paused) {
                videoPlayer.play();
            } else {
                videoPlayer.pause();
            }
        }

        function skipTime(delta) {
            videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime + delta);
        }

        // Event listeners
        videoInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                videoPlayer.src = url;
                state.videoLoaded = true;
                document.getElementById('videoName').textContent = file.name;
                document.getElementById('videoStatus').classList.add('loaded');
            }
        });

        subtitle1Input.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                try {
                    const content = await file.text();
                    console.log('Subtitle 1 raw content length:', content.length);
                    console.log('First 500 chars:', content.substring(0, 500));
                    
                    state.subtitles1 = parseSubtitle(content, file.name);
                    state.originalFilename1 = file.name.replace(/\.(srt|vtt|txt)$/i, '');
                    updateSubtitleList(1);
                    document.getElementById('sub1Name').textContent = file.name;
                    document.getElementById('sub1Count').textContent = `(${state.subtitles1.length} æ¢)`;
                    document.getElementById('sub1Status').classList.add('loaded');
                    
                    if (state.subtitles1.length === 0) {
                        alert('å­—å¹•1 è§£æå¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ ¼å¼æ˜¯å¦æ­£ç¢ºï¼ˆSRT æˆ– VTTï¼‰');
                    }
                } catch (err) {
                    console.error('Error loading subtitle 1:', err);
                    alert('è¼‰å…¥å­—å¹•1æ™‚ç™¼ç”ŸéŒ¯èª¤: ' + err.message);
                }
            }
        });

        subtitle2Input.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                try {
                    const content = await file.text();
                    console.log('Subtitle 2 raw content length:', content.length);
                    console.log('First 500 chars:', content.substring(0, 500));
                    
                    state.subtitles2 = parseSubtitle(content, file.name);
                    state.originalFilename2 = file.name.replace(/\.(srt|vtt|txt)$/i, '');
                    updateSubtitleList(2);
                    document.getElementById('sub2Name').textContent = file.name;
                    document.getElementById('sub2Count').textContent = `(${state.subtitles2.length} æ¢)`;
                    document.getElementById('sub2Status').classList.add('loaded');
                    
                    if (state.subtitles2.length === 0) {
                        alert('å­—å¹•2 è§£æå¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ ¼å¼æ˜¯å¦æ­£ç¢ºï¼ˆSRT æˆ– VTTï¼‰');
                    }
                } catch (err) {
                    console.error('Error loading subtitle 2:', err);
                    alert('è¼‰å…¥å­—å¹•2æ™‚ç™¼ç”ŸéŒ¯èª¤: ' + err.message);
                }
            }
        });

        // Offset input listeners
        ['1', '2'].forEach(num => {
            document.getElementById(`offset${num}Min`).addEventListener('change', () => setOffsetFromInputs(parseInt(num)));
            document.getElementById(`offset${num}Sec`).addEventListener('change', () => setOffsetFromInputs(parseInt(num)));
            document.getElementById(`offset${num}Slider`).addEventListener('input', (e) => {
                if (num === '1') {
                    state.offset1 = parseFloat(e.target.value);
                } else {
                    state.offset2 = parseFloat(e.target.value);
                }
                updateOffsetDisplay(parseInt(num));
                updateSubtitleList(parseInt(num));
            });
        });

        // Video time update
        videoPlayer.addEventListener('timeupdate', updateSubtitleDisplay);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;
            
            switch(e.key) {
                case ' ':
                    e.preventDefault();
                    togglePlay();
                    break;
                case 'ArrowLeft':
                    skipTime(-5);
                    break;
                case 'ArrowRight':
                    skipTime(5);
                    break;
            }
        });
    </script>
</body>
</html>
